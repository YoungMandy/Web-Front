无论是手写虚拟DOM(渲染函数)还是使用模版，都属于声明式地描述UI，并且Vue.js同时支持这两种描述UI的方式。

编译器和渲染器一样，只是一段程序而已，不过它们的工作内容不同。**编译器的作用其实是将模版编译为渲染函数**，例如给出如下模板
```javascript
<div @click="handler">click me</div>
```

对于编译器来说，模版就是一个普通的字符串，它会分析该字符串并生成一个功能与之相同的渲染函数
```javascript
render(){
  return h(
    'div',
    {
      onClick:handler
    },
    'click me'
  )
}

```
以我们熟悉的`.vue`文件为例,一个`.vue`文件就是一个组件，如下所示
```vue
<template>
  <div @click="handler">
    click me 
  </div>
</template>

<script>
export default {
  data():{/* ... */},
  methods:{
    handler:()=>{/* ... */},
  },
}
</script>
```

其中`<template>`标签里的内容就是模版内容，编译器会把模版内容编译成渲染函数并添加到`<script>`标签块的组件对象上，所以最终在浏览器里运行的代码就是:
```javascript
export default {
  data():{/* ... */},
  methods:{
    handler:()=>{/* ... */},
  },
  render(){
    return h('div',{ onClick: handler },'click me')
  }
}
```
所以，无论是使用模版还是直接手写渲染函数，对于一个组件来说，它要渲染的内容最终是通过渲染函数产生的，然后渲染器再把渲染函数返回的虚拟DOM渲染为真实DOM。这就是模版的工作原理，也是Vue.js渲染页面的流程。

### Vue.js是各个模块组成的有机整体
组件的实现依赖于渲染器，模版的编译依赖于编译器，并且**编译后生成的代码是根据渲染器和虚拟DOM的设计决定的**，因此Vue.js的各个模块之间是互相关联、互相制约的，共同构成一个有机整体。


**编译器和渲染器之间是存在信息交流的，它们互相配合使得性能进一步提升，而它们之间交流的媒介就是虚拟DOM对象**

```javascript
<div id="foo" :class="cls"></div>
```

编译器会把这段代码编译成渲染函数：
```javascript
render(){
  // 为了效果更加只管，这里没有使用h函数,而是直接采用了虚拟DOM对象
  // 下面的代码等价于
  // return h('div',{ id:'foo' , class: cls })

  return {
    tag:'div',
    props:{
      id:'foo',
      class:cls
    }
  }
}
```
可以发现，在这段代码中，`cls`是一个变量，它可能会发生变化。我们知道渲染器的作用之一就是寻找并且只更新变化的内容，所以当变量`cls`的值发生变化时，渲染器会自行寻找变更点。

对于渲染器来说，这个“寻找”的过程需要花费一些力气。那么从 编译器的视角来看，它是否知道哪些内容会发生变化呢？如果编译器有能力分析动态内容，并在编译阶段把这些信息提取出来，然后直接交给渲染器，这样渲染器不就不需要花费大力气去寻找变更点了吗？这是个好想法并且可以实现。 `Vue.js`的模版是有特点的，拿上面的模版来说，我们一眼能看出其中`id="foo"`是永远不会变化的，而`:class="cls"`是一个`v-bind`绑定，它是可能发生变化的。所以**编译器能识别出哪些是静态属性，哪些是动态属性**,在生成代码的时候完全可以附带这些信息:
```javascript
render(){
  return {
    tag:"div",
    props:{
      id:'foo',
      class:cls
    },
    patchFlag:1 // 假设数字1代表class 是动态的
  }
}
```
如上面的代码所示，在生成的虚拟DOM对象中多了一个`patchFlags`属性，我们假设数字1代表"class是动态的",这样渲染器看到这个标志时就知道"哦，原来只有class属性会发生改变。"对于渲染器来说，就相当于省去了寻找变更点的工作量，性能自然就提升了。

`Vue.js`是一个声明式的框架，它直接描述结果，用户不需要关心过程。`Vue.js`采用模版的方式来描述UI，但它同样支持`虚拟DOM`来描述UI。虚拟DOM要比模版更加灵活，但模版要比虚拟DOM更加直观。


