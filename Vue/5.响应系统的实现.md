基本流程：
```javascript
const obj = { text: 'Hello' };

function effect(){
  // effect 函数的执行会读取obj.text
  document.body.innerText = obj.text;
}
```
当读取`obj.text`的时候，将使用这个属性的函数存储到一个桶里，
当设置`obj.text`时，将桶里的函数取出来执行一边。

利用的上面的思路，采用ES2015+ 的Proxy来实现

#### 第一个版本的响应式系统
```javascript
// 存储副作用函数的桶
const bucket = new Set();

// 原始数据
const data = { text:'hello world' };

// 对原始数据的代理
const obj = new Proxy(data,{
  // 拦截读取操作
  get(target,key){
    // 将副作用函数effect添加到桶里
    bucket.add(effect);

    // 返回属性值
    return target[key];
  },
  // 设置拦截操作
  set(target, key, newVal){
    // 设置属性值
    target[key] = newVal;

    // 把副作用函数从桶里取出并执行
    bucket.forEach(fn => fn());

    // 返回true代表设置成功
    return true;
  }
})

```
目前的实现还存在很多缺陷，例如我们直接通过名字(effect)来获取副作用函数，这种硬编码的方式不是很灵活。副作用函数的名字可以任意取，我们完全可以把副作用函数命名为myEffect,甚至是一个匿名函数，因此我们要想办法去掉这种硬编码的机制。



从上面的例子可以看出，一个响应式系统的工作流程如下：
* 当**读取**操作发生时，将副作用函数收集到"桶"中
* 当**设置**操作发生事，从"桶"中取出副作用函数并执行

哪怕副作用函数是一个匿名函数，也能被正确地收集到"桶"中。为了实现这一点，我们需要提供一个用来注册副作用函数的机制。
```javascript
// 用一个全局变量存储被注册的副作用函数
let activeEffect;
// effect 函数用于注册副作用函数

function effect(fn){
  // 当调用effect注册副作用函数时，将副作用那个函数注册给activeEffect
  activeEffect = fn;

  // 执行副作用函数
  fn();
}

```
首先，定义了一个全局变量activeEffect,初始化值是undefined,它的作用是存储被注册的副作用函数。接着重新定义了effect函数，它变成了一个用来注册副作用函数的函数,effect函数接受一个参数fn，即要注册的副作用函数。
我们可以按照如下所示的凡是使用effect函数
```javascript
effect(
  // 一个匿名的副作用函数
  () => {
    document.body.innerText = obj.text
  }
)
```

我们使用一个匿名的副作用函数作为effect函数的参数。当effect函数执行时，首先会把匿名的副作用函数fn赋值给全局变量activeEffect。接着执行被注册的匿名函数fn,这将会触发响应式数据obj.text的读取操作，进而触发代理对象Proxy的get拦截函数。

```javascript
const obj = new Proxy(data, {
  get(target,key){
    // 将activeEffect 中存储的副作用函数收集到"桶"中
    if(activeEffect){ // 新增
      bucket.add(activeEffect)// 新增
    }

    return target[key];
  },
  set(target, key, newVal){
    target[key] = newVal;
    bucket.forEach(fn =>fn());

    return true;
  }
})
```